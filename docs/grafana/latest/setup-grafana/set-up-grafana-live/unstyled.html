<!DOCTYPE html>
<h1 id="set-up-grafana-live">Set up Grafana Live</h1>
<p>Grafana Live is a real-time messaging engine you can use to push event data to a frontend as soon as an event occurs.</p>
<p>This could be notifications about dashboard changes, new frames for rendered data, and so on. Live features can help eliminate a page reload or polling in many places, it can stream Internet of things (IoT) sensors or any other real-time data to panels.</p>


<div class="admonition admonition-note"><blockquote><p class="title text-uppercase">Note</p><p>By <code>real-time</code>, we indicate a soft real-time. Due to network latencies, garbage collection cycles, and so on, the delay of a delivered message can be up to several hundred milliseconds or higher.</p></blockquote></div>

<h2 id="concepts">Concepts</h2>
<p>Grafana Live sends data to clients over persistent WebSocket connections, based on a Pub/Sub model. The Grafana frontend subscribes on each channel to receive data that has been published in that channel. All subscriptions on a page are multiplexed inside a single WebSocket connection. There are some rules regarding Live channel names – see <a href="#grafana-live-channel">Grafana Live channel</a>.</p>
<p>Handling persistent connections like WebSocket in scale may require operating system and infrastructure tuning. That&rsquo;s why by default Grafana Live supports 100 simultaneous connections max. For more details on how to tune this limit, refer to <a href="#configure-grafana-live">Live configuration section</a>.</p>
<h2 id="features">Features</h2>
<p>Having a way to send data to clients in real-time opens a road for new ways of data interaction and visualization. Below we describe Grafana Live features supported at the moment.</p>
<h3 id="dashboard-change-notifications">Dashboard change notifications</h3>
<p>As soon as there is a change to the dashboard layout, it is automatically reflected on other devices connected to Grafana Live.</p>
<h3 id="data-streaming-from-plugins">Data streaming from plugins</h3>
<p>With Grafana Live, backend data source plugins can stream updates to frontend panels.</p>
<p>For data source plugin channels, Grafana uses <code>ds</code> scope. Namespace in the case of data source channels is a data source unique ID (UID) which is issued by Grafana at the moment of data source creation. The path is a custom string that plugin authors free to choose themselves (just make sure it consists of allowed symbols).</p>
<p>For example, a data source channel looks like this: <code>ds/&lt;DATASOURCE_UID&gt;/&lt;CUSTOM_PATH&gt;</code>.</p>
<p>Refer to the tutorial about <a href="/tutorials/build-a-streaming-data-source-plugin/">building a streaming data source backend plugin</a> for more details.</p>
<p>The basic streaming example included in Grafana core streams frames with some generated data to a panel. To look at it create a new panel and point it to the <code>-- Grafana --</code> data source. Next, choose <code>Live Measurements</code> and select the <code>plugin/testdata/random-20Hz-stream</code> channel.</p>
<h3 id="data-streaming-from-telegraf">Data streaming from Telegraf</h3>
<p>A new API endpoint <code>/api/live/push/:streamId</code> allows accepting metrics data in Influx format from Telegraf. These metrics are transformed into Grafana data frames and published to channels.</p>
<p>Refer to the tutorial about <a href="/tutorials/stream-metrics-from-telegraf-to-grafana/">streaming metrics from Telegraf to Grafana</a> for more information.</p>
<h2 id="grafana-live-channel">Grafana Live channel</h2>
<p>Grafana Live is a PUB/SUB server, clients subscribe to channels to receive real-time updates published to those channels.</p>
<h3 id="channel-structure">Channel structure</h3>
<p>Channel is a string identifier. In Grafana channel consists of 3 parts delimited by <code>/</code>:</p>
<ul>
<li>Scope</li>
<li>Namespace</li>
<li>Path</li>
</ul>
<p>For example, the channel <code>grafana/dashboard/xyz</code> has the scope <code>grafana</code>, namespace <code>dashboard</code>, and path <code>xyz</code>.</p>
<p>Scope, namespace and path can only have ASCII alphanumeric symbols (A-Z, a-z, 0-9), <code>_</code> (underscore) and <code>-</code> (dash) at the moment. The path part can additionally have <code>/</code>, <code>.</code> and <code>=</code> symbols. The meaning of scope, namespace and path is context-specific.</p>
<p>The maximum length of a channel is 160 symbols.</p>
<p>Scope determines the purpose of a channel in Grafana. For example, for data source plugin channels Grafana uses <code>ds</code> scope. For built-in features like dashboard edit notifications Grafana uses <code>grafana</code> scope.</p>
<p>Namespace has a different meaning depending on scope. For example, for <code>grafana</code> scope this could be a name of built-in real-time feature like <code>dashboard</code> (i.e. dashboards events).</p>
<p>The path, which is the final part of a channel, usually contains the identifier of some concrete resource such as the ID of a dashboard that a user is currently looking at. But a path can be anything.</p>
<p>Channels are lightweight and ephemeral - they are created automatically on user subscription and removed as soon as last user left a channel.</p>
<h3 id="data-format">Data format</h3>
<p>All data travelling over Live channels must be JSON-encoded.</p>
<h2 id="configure-grafana-live">Configure Grafana Live</h2>
<p>Grafana Live is enabled by default. In Grafana v8.0, it has a strict default for a maximum number of connections per Grafana server instance.</p>
<h3 id="max-number-of-connections">Max number of connections</h3>
<p>Grafana Live uses persistent connections (WebSocket at the moment) to deliver real-time updates to clients.</p>
<p>WebSocket is a persistent connection that starts with an HTTP Upgrade request (using the same HTTP port as the rest of Grafana) and then switches to a TCP mode where WebSocket frames can travel in both directions between a client and a server. Each logged-in user opens a WebSocket connection – one per browser tab.</p>
<p>The number of maximum WebSocket connections users can establish with Grafana is limited to 100 by default. See <a href="../configure-grafana/#max_connections">max_connections</a> option.</p>
<p>In case you want to increase this limit, ensure that your server and infrastructure allow handling more connections. The following sections discuss several common problems which could happen when managing persistent connections, in particular WebSocket connections.</p>
<h3 id="request-origin-check">Request origin check</h3>
<p>To avoid hijacking of WebSocket connection Grafana Live checks the Origin request header sent by a client in an HTTP Upgrade request. Requests without Origin header pass through without any origin check.</p>
<p>By default, Live accepts connections with Origin header that matches configured <a href="../configure-grafana/#root_url">root_url</a> (which is a public Grafana URL).</p>
<p>It is possible to provide a list of additional origin patterns to allow WebSocket connections from. This can be achieved using the <a href="../configure-grafana/#allowed_origins">allowed_origins</a> option of Grafana Live configuration.</p>
<h4 id="resource-usage">Resource usage</h4>
<p>Each persistent connection costs some memory on a server. Typically, this should be about 50 KB per connection at this moment. Thus a server with 1 GB RAM is expected to handle about 20k connections max. Each active connection consumes additional CPU resources since the client and server send PING/PONG frames to each other to maintain a connection.</p>
<p>Using the streaming functionality results in additional CPU usage. The exact CPU resource utilization can be hard to estimate as it heavily depends on the Grafana Live usage pattern.</p>
<h4 id="open-file-limit">Open file limit</h4>
<p>Each WebSocket connection costs a file descriptor on a server machine where Grafana runs. Most operating systems have a quite low default limit for the maximum number of descriptors that process can open.</p>
<p>To look at the current limit on Unix run:</p>
<pre>ulimit -n</pre>
<p>On a Linux system, you can also check out the current limits for a running process with:</p>
<pre>cat /proc/&lt;PROCESS_PID&gt;/limits</pre>
<p>The open files limit shows approximately how many user connections your server can currently handle.</p>
<p>To increase this limit, refer to <a href="https://docs.riak.com/riak/kv/2.2.3/using/performance/open-files-limit.1.html" target="_blank" rel="noopener noreferrer">these instructions</a> for popular operating systems.</p>
<h4 id="ephemeral-port-exhaustion">Ephemeral port exhaustion</h4>
<p>Ephemeral port exhaustion problem can happen between your load balancer (or reverse proxy) software and Grafana server. For example, when you load balance requests/connections between different Grafana instances. If you connect directly to a single Grafana server instance, then you should not come across this issue.</p>
<p>The problem arises because each TCP connection uniquely identified in the OS by the 4-part-tuple:</p>
<pre>source ip | source port | destination ip | destination port</pre>
<p>By default, on load balancer/server boundary you are limited to 65535 possible variants. But actually, due to some OS limits (for example on Unix available ports defined in <code>ip_local_port_range</code> sysctl parameter) and sockets in TIME_WAIT state, the number is even less.</p>
<p>In order to eliminate a problem you can:</p>
<ul>
<li>Increase the ephemeral port range by tuning <code>ip_local_port_range</code> kernel option.</li>
<li>Deploy more Grafana server instances to load balance across.</li>
<li>Deploy more load balancer instances.</li>
<li>Use virtual network interfaces.</li>
</ul>
<h4 id="websocket-and-proxies">WebSocket and proxies</h4>
<p>Not all proxies can transparently proxy WebSocket connections by default. For example, if you are using Nginx before Grafana you need to configure WebSocket proxy like this:</p>
<pre>http {
    map $http_upgrade $connection_upgrade {
        default upgrade;
        &#39;&#39; close;
    }

    upstream grafana {
        server 127.0.0.1:3000;
    }

    server {
        listen 8000;

        location / {
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_set_header Host $http_host;
            proxy_pass http://grafana;
        }
    }
}</pre>
<p>See the <a href="https://www.nginx.com/blog/websocket-nginx/" target="_blank" rel="noopener noreferrer">Nginx blog on their website</a> for more information. Also, refer to your load balancer/reverse proxy documentation to find out more information on dealing with WebSocket connections.</p>
<p>Some corporate proxies can remove headers required to properly establish a WebSocket connection. In this case, you should tune intermediate proxies to not remove required headers. However, the better option is to use Grafana with TLS. Now WebSocket connection will inherit TLS and thus must be handled transparently by proxies.</p>
<p>Proxies like Nginx and Envoy have default limits on maximum number of connections which can be established. Make sure you have a reasonable limit for max number of incoming and outgoing connections in your proxy configuration.</p>
<h2 id="configure-grafana-live-ha-setup">Configure Grafana Live HA setup</h2>
<p>By default, Grafana Live uses in-memory data structures and in-memory PUB/SUB hub for handling subscriptions.</p>
<p>In a high availability Grafana setup involving several Grafana server instances behind a load balancer, you can find the following limitations:</p>
<ul>
<li>Built-in features like dashboard change notifications will only be broadcasted to users connected to the same Grafana server process instance.</li>
<li>Streaming from Telegraf will deliver data only to clients connected to the same instance which received Telegraf data, active stream cache is not shared between different Grafana instances.</li>
<li>A separate unidirectional stream between Grafana and backend data source may be opened on different Grafana servers for the same channel.</li>
</ul>
<p>To bypass these limitations, Grafana has a Live HA engine that requires Redis to work.</p>
<h3 id="configure-redis-live-engine">Configure Redis Live engine</h3>
<p>When the Redis engine is configured, Grafana Live keeps its state in Redis and uses Redis PUB/SUB functionality to deliver messages to all subscribers throughout all Grafana server nodes.</p>
<p>Here is an example configuration:</p>
<pre>[live]
ha_engine = redis
ha_engine_address = 127.0.0.1:6379</pre>
<p>For additional information, refer to the <a href="../configure-grafana/#ha_engine">ha_engine</a> and <a href="../configure-grafana/#ha_engine_address">ha_engine_address</a> options.</p>
<p>After running:</p>
<ul>
<li>All built-in real-time notifications like dashboard changes are delivered to all Grafana server instances and broadcasted to all subscribers.</li>
<li>Streaming from Telegraf delivers messages to all subscribers.</li>
<li>A separate unidirectional stream between Grafana and backend data source opens on different Grafana servers. Publishing data to a channel delivers messages to instance subscribers, as a result, publications from different instances on different machines do not produce duplicate data on panels.</li>
</ul>


<div class="admonition admonition-note"><blockquote><p class="title text-uppercase">Note</p><p>Live currently does not support Redis Sentinel. We recommend using a Redis Cluster for high-availability via a k8s helm chart such as the Bitnami Redis chart which has values to provision a Redis Cluster. Grafana Live can then be pointed to the <code>redis-headless</code> service.</p>
<pre> live:
   ha_engine: redis
   ha_engine_address: redis-headless.grafana.svc.cluster.local:6379
   ha_engine_password: $__file{/your/redis/password/secret/mount}</pre></blockquote></div>



<div class="admonition admonition-note"><blockquote><p class="title text-uppercase">Note</p><p>The Redis Live HA engine does not currently support TLS.</p></blockquote></div>

